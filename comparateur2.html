<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comparateur BC L4 - Applications</title>
    <link rel="stylesheet" href="comparator-styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚öñÔ∏è Comparateur BC L4</h1>
            <p>Comparez les Business Capabilities L4 de vos applications</p>
            
            <!-- Slider de niveaux de d√©tail -->
            <div class="detail-level-container">
                <span style="font-size: 0.9em; opacity: 0.8;">Niveau de d√©tail:</span>
                <div class="detail-slider" onclick="setDetailLevel(event)">
                    <div class="detail-slider-track" id="slider-track"></div>
                    <div class="detail-slider-thumb" id="slider-thumb"></div>
                </div>
            </div>
        </div>
        
        <!-- Onglets L1 pour niveau 2 -->
        <div class="l1-tabs" id="l1-tabs">
            <!-- Les onglets L1 seront g√©n√©r√©s dynamiquement -->
        </div>

        <div class="main-content">
            <!-- Sidebar de s√©lection -->
            <div class="sidebar">
                <!-- Recherche -->
                <div class="search-section">
                    <input type="text" id="app-search" class="search-input" 
                           placeholder="üîç Rechercher une application...">
                </div>

                <!-- Applications s√©lectionn√©es -->
                <div class="selected-section">
                    <div class="section-title">
                        üìã S√©lectionn√©es (<span id="selected-count">0</span>/4)
                    </div>
                    <div id="selected-apps" class="selected-apps">
                        <div class="no-selection">
                            Aucune application s√©lectionn√©e
                        </div>
                    </div>
                </div>

                <!-- Applications disponibles -->
                <div class="available-section">
                    <div class="section-title">
                        üì± Applications disponibles
                    </div>
                    <div id="available-apps" class="available-apps">
                        <!-- Les applications seront charg√©es ici -->
                    </div>
                </div>
            </div>

            <!-- Zone de comparaison -->
            <div class="comparison-area">
                <div id="comparison-content">
                    <div class="empty-state">
                        <div class="empty-state-icon">üìä</div>
                        <h3>Comparaison des Business Capabilities L4</h3>
                        <p>S√©lectionnez au moins 2 applications pour voir la comparaison</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let selectedApps = [];
        let allApplications = [];
        let bcL4Definitions = {}; // D√©finitions des BC L4
        let currentDetailLevel = 3; // Niveau de d√©tail actuel (1: Vue G√©n√©rale | 2: Vue Processus | 3: Vue D√©taill√©e)
        let currentL1Filter = null; // Filtre L1 actuel pour le niveau 2
        let capabilitiesData = null; // Donn√©es des capabilities depuis la carte

        // Initialisation
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üöÄ Initialisation du comparateur standalone');
            await loadApplications(); // Attendre le chargement des apps ET des d√©finitions
            await loadCapabilitiesStructure(); // Attendre le chargement des capabilities
            setupEventListeners();
            loadSavedSelection(); // Maintenant on peut charger la s√©lection en toute s√©curit√©
            initializeDetailSlider();
        });

        // Interface ind√©pendante - charger depuis localStorage
        function loadSavedSelection() {
            try {
                const saved = localStorage.getItem('comparatorApps');
                if (saved) {
                    const comparatorApps = JSON.parse(saved);
                    console.log(`üìã Chargement depuis localStorage: ${comparatorApps.length} applications`);
                    
                    // Ajouter les applications sauvegard√©es
                    comparatorApps.forEach(app => {
                        if (selectedApps.length < 4) {
                            selectedApps.push(app);
                        }
                    });
                    
                    updateInterface();
                    console.log(`‚úÖ ${selectedApps.length} applications charg√©es dans le comparateur`);
                } else {
                    console.log('üöÄ Comparateur d√©marr√© en mode standalone - aucune application sauvegard√©e');
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Erreur lors du chargement depuis localStorage:', error);
                console.log('üöÄ Comparateur d√©marr√© en mode standalone');
            }
        }

        // Charger les applications
        async function loadApplications() {
            try {
                const response = await fetch('data.json');
                allApplications = await response.json();
                console.log('‚úÖ Applications charg√©es:', allApplications.length);
                
                // Charger les d√©finitions des L4
                try {
                    const definitionsResponse = await fetch('bc-l4-definitions.json');
                    if (definitionsResponse.ok) {
                        bcL4Definitions = await definitionsResponse.json();
                        console.log('‚úÖ D√©finitions L4 charg√©es:', Object.keys(bcL4Definitions).length, 'L4 d√©finis');
                    } else {
                        console.warn('‚ö†Ô∏è Impossible de charger bc-l4-definitions.json');
                    }
                } catch (defError) {
                    console.warn('‚ö†Ô∏è Erreur lors du chargement des d√©finitions L4:', defError);
                }
                
                // Charger le mapping L3 -> L4
                try {
                    const mappingResponse = await fetch('bc-l4-mapping.json');
                    if (mappingResponse.ok) {
                        window.bcL4Mapping = await mappingResponse.json();
                        console.log('‚úÖ Mapping L4 charg√©:', Object.keys(window.bcL4Mapping).length, 'mappings d√©finis');
                    } else {
                        console.warn('‚ö†Ô∏è Impossible de charger bc-l4-mapping.json');
                    }
                } catch (mappingError) {
                    console.warn('‚ö†Ô∏è Erreur lors du chargement du mapping L4:', mappingError);
                }
                
                renderAvailableApps();
            } catch (error) {
                console.error('‚ùå Erreur chargement applications:', error);
                document.getElementById('available-apps').innerHTML = 
                    '<p style="color: red; text-align: center;">Erreur de chargement des donn√©es</p>';
            }
        }

        // Fonction pour obtenir la d√©finition d'un L4 ou son nom par d√©faut
        function getL4DisplayName(l4Id) {
            return bcL4Definitions[l4Id] || l4Id;
        }

        // === FONCTIONS DE GESTION DES NIVEAUX DE D√âTAIL ===

        // Initialiser le slider de niveau de d√©tail
        function initializeDetailSlider() {
            updateSliderPosition();
        }

        // D√©finir le niveau de d√©tail
        function setDetailLevel(event, level) {
            if (event) {
                // Calculer le niveau bas√© sur la position du clic
                const slider = event.currentTarget;
                const rect = slider.getBoundingClientRect();
                const position = (event.clientX - rect.left) / rect.width;
                
                if (position < 0.33) level = 1;
                else if (position < 0.66) level = 2;
                else level = 3;
            }
            
            currentDetailLevel = level;
            updateSliderPosition();
            updateComparison();
            
            // G√©rer l'affichage des onglets L1 pour le niveau 2
            const l1Tabs = document.getElementById('l1-tabs');
            if (level === 2) {
                generateL1Tabs();
                l1Tabs.classList.add('show');
            } else {
                l1Tabs.classList.remove('show');
                currentL1Filter = null;
            }
        }

        // Mettre √† jour la position visuelle du slider
        function updateSliderPosition() {
            const thumb = document.getElementById('slider-thumb');
            const track = document.getElementById('slider-track');
            
            let position;
            switch(currentDetailLevel) {
                case 1: position = 0; break;
                case 2: position = 50; break;
                case 3: position = 100; break;
            }
            
            thumb.style.left = `calc(${position}% - 10px)`;
            track.style.width = `${position}%`;
        }

        // Charger les capabilities depuis capabilities.json
        let capabilitiesStructure = null;
        
        // Charger la structure des capabilities
        async function loadCapabilitiesStructure() {
            try {
                const response = await fetch('capabilities.json');
                if (response.ok) {
                    capabilitiesStructure = await response.json();
                    console.log('‚úÖ Structure des capabilities charg√©e:', Object.keys(capabilitiesStructure).length, 'capabilities');
                } else {
                    console.warn('‚ö†Ô∏è Impossible de charger capabilities.json');
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Erreur lors du chargement des capabilities:', error);
            }
        }

        // G√©n√©rer les onglets L1 pour le niveau 2
        function generateL1Tabs() {
            const l1Tabs = document.getElementById('l1-tabs');
            
            const l1Set = new Set();
            
            if (capabilitiesStructure) {
                // Utiliser les vraies donn√©es depuis capabilities.json
                selectedApps.forEach(app => {
                    if (app.capabilities) {
                        app.capabilities.forEach(capId => {
                            // Chercher cette capability dans la structure des capabilities
                            if (capabilitiesStructure[capId] && capabilitiesStructure[capId].l1_name) {
                                l1Set.add(capabilitiesStructure[capId].l1_name);
                            }
                        });
                    }
                });
            }
            
            if (l1Set.size === 0) {
                // Valeurs par d√©faut bas√©es sur les vrais L1 de capabilities.json
                l1Set.add('Order Management');
                l1Set.add('Transport Management');
                l1Set.add('Carrier Management');
                l1Set.add('Finance Management');
            }
            
            const l1Array = Array.from(l1Set).sort();
            
            let html = '';
            l1Array.forEach((l1Name, index) => {
                const isActive = currentL1Filter === l1Name || (currentL1Filter === null && index === 0);
                html += `<span class="l1-tab ${isActive ? 'active' : ''}" onclick="selectL1Tab('${l1Name}')">${l1Name}</span>`;
            });
            
            l1Tabs.innerHTML = html;
            
            // S√©lectionner le premier onglet par d√©faut
            if (currentL1Filter === null && l1Array.length > 0) {
                currentL1Filter = l1Array[0];
            }
        }

        // S√©lectionner un onglet L1
        function selectL1Tab(l1Name) {
            currentL1Filter = l1Name;
            
            // Mettre √† jour l'apparence des onglets
            document.querySelectorAll('.l1-tab').forEach(tab => {
                tab.classList.toggle('active', tab.textContent === l1Name);
            });
            
            // Mettre √† jour la comparaison
            updateComparison();
        }

        // Configuration des √©v√©nements
        function setupEventListeners() {
            document.getElementById('app-search').addEventListener('input', filterApps);
        }

        // Afficher les applications disponibles
        function renderAvailableApps() {
            const container = document.getElementById('available-apps');
            
            if (!allApplications.length) {
                container.innerHTML = '<p style="text-align: center; color: #999;">Aucune application trouv√©e</p>';
                return;
            }

            container.innerHTML = allApplications.map(app => {
                const isSelected = selectedApps.some(selected => selected.name === app.name);
                const canAdd = selectedApps.length < 4;
                const capCount = app.capabilities ? app.capabilities.length : 0;

                return `
                    <div class="app-item ${isSelected ? 'selected' : ''} ${!canAdd && !isSelected ? 'disabled' : ''}" 
                         onclick="toggleApp('${app.name}')">
                        <div class="app-info">
                            <div class="app-name">${app.name}</div>
                            <div class="app-details">
                                ${app.category || 'Non cat√©goris√©'} ‚Ä¢ ${capCount} Capabilities
                            </div>
                        </div>
                        <div class="app-icon">
                            ${isSelected ? '‚úÖ' : (canAdd ? '‚ûï' : 'üö´')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Basculer la s√©lection d'une application
        function toggleApp(appName) {
            const isSelected = selectedApps.some(app => app.name === appName);

            if (isSelected) {
                selectedApps = selectedApps.filter(app => app.name !== appName);
            } else {
                if (selectedApps.length >= 4) {
                    alert('Maximum 4 applications peuvent √™tre s√©lectionn√©es');
                    return;
                }
                const app = allApplications.find(a => a.name === appName);
                if (app) {
                    selectedApps.push(app);
                }
            }

            updateInterface();
        }

        // Supprimer une application s√©lectionn√©e
        function removeApp(index) {
            selectedApps.splice(index, 1);
            updateInterface();
        }

        // Mettre √† jour l'interface
        function updateInterface() {
            updateSelectedApps();
            renderAvailableApps();
            updateComparison();
        }

        // Mettre √† jour les applications s√©lectionn√©es
        function updateSelectedApps() {
            const container = document.getElementById('selected-apps');
            const countElement = document.getElementById('selected-count');

            countElement.textContent = selectedApps.length;

            if (selectedApps.length === 0) {
                container.innerHTML = '<div class="no-selection">Aucune application s√©lectionn√©e</div>';
                return;
            }

            container.innerHTML = selectedApps.map((app, index) => {
                const capCount = app.capabilities ? app.capabilities.length : 0;
                return `
                    <div class="selected-app-item">
                        <div class="app-info">
                            <div class="app-name">${app.name}</div>
                            <div class="app-details">${capCount} Capabilities</div>
                        </div>
                        <button class="remove-btn" onclick="removeApp(${index})" title="Supprimer">√ó</button>
                    </div>
                `;
            }).join('');
        }

        // Mettre √† jour la comparaison selon le niveau de d√©tail
        function updateComparison() {
            const container = document.getElementById('comparison-content');

            if (selectedApps.length < 2) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìä</div>
                        <h3>Comparaison des Business Capabilities</h3>
                        <p>S√©lectionnez au moins 2 applications pour voir la comparaison</p>
                    </div>
                `;
                return;
            }

            let comparisonHtml;
            switch(currentDetailLevel) {
                case 1:
                    comparisonHtml = generateL1L2Comparison();
                    break;
                case 2:
                    comparisonHtml = generateL2L3Comparison();
                    break;
                case 3:
                default:
                    comparisonHtml = generateL3L4Comparison();
                    break;
            }
            
            container.innerHTML = comparisonHtml;
        }

        // G√©n√©rer la comparaison L1, L2 (Niveau 1)
        function generateL1L2Comparison() {
            if (!capabilitiesStructure) {
                console.warn('‚ö†Ô∏è Structure des capabilities non charg√©e');
                return `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ö†Ô∏è</div>
                        <h3>Structure des capabilities non charg√©e</h3>
                        <p>Impossible de charger les donn√©es depuis capabilities.json</p>
                    </div>
                `;
            }
            
            // Collecter toutes les capabilities des applications s√©lectionn√©es
            const allCapabilitiesFromApps = new Set();
            selectedApps.forEach(app => {
                if (app.capabilities) {
                    app.capabilities.forEach(cap => allCapabilitiesFromApps.add(cap));
                }
            });
            
            // D√©duire la structure L1 -> L2 √† partir des capabilities des applications
            const l1Structure = {};
            allCapabilitiesFromApps.forEach(capabilityId => {
                const capData = capabilitiesStructure[capabilityId];
                if (capData && capData.l1_name && capData.l2_name) {
                    if (!l1Structure[capData.l1_name]) {
                        l1Structure[capData.l1_name] = new Set();
                    }
                    l1Structure[capData.l1_name].add(capData.l2_name);
                }
            });
            
            // Convertir les Sets en Arrays tri√©s
            Object.keys(l1Structure).forEach(l1 => {
                l1Structure[l1] = Array.from(l1Structure[l1]).sort();
            });
            
            const l1Names = Object.keys(l1Structure).sort();
            
            if (l1Names.length === 0) {
                return `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ùå</div>
                        <h3>Aucun L1/L2 trouv√©</h3>
                        <p>Les applications s√©lectionn√©es n'ont pas de capabilities identifiables dans capabilities.json</p>
                    </div>
                `;
            }
            
            let html = `
                <div class="comparison-table">
                    <div class="table-header">
                        <h3>Comparaison par Domaines (L1) et Processus (L2)</h3>
                        <div class="comparison-stats">
                            <div class="stat-item">${selectedApps.length} Applications</div>
                            <div class="stat-item">${l1Names.length} Domaines L1</div>
                        </div>
                    </div>
                    <table class="capability-table">
                        <thead>
                            <tr>
                                <th class="capability-name">Domaine / Processus</th>
                                ${selectedApps.map(app => `<th class="app-column">${app.name}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // G√©n√©rer les lignes pour chaque L1 et ses L2
            l1Names.forEach(l1 => {
                // Ligne L1 (domaine principal)
                html += `<tr class="l1-row">`;
                html += `<td class="capability-name l1-header"><strong>üìÅ ${l1}</strong></td>`;
                
                selectedApps.forEach(app => {
                    // Pour L1, v√©rifier si l'app a au moins une capability de ce domaine
                    let hasL1 = false;
                    if (app.capabilities && capabilitiesStructure) {
                        hasL1 = app.capabilities.some(capId => {
                            const capData = capabilitiesStructure[capId];
                            return capData && capData.l1_name === l1;
                        });
                    }
                    const cellClass = hasL1 ? 'implemented' : 'not-implemented';
                    const icon = hasL1 ? '‚úì' : '‚úó';
                    html += `<td class="app-column ${cellClass}">${icon}</td>`;
                });
                
                html += `</tr>`;
                
                // Lignes L2 (processus sous ce domaine)
                l1Structure[l1].forEach(l2 => {
                    html += `<tr class="l2-row">`;
                    html += `<td class="capability-name l2-name">‚îî‚îÄ ${l2}</td>`;
                    
                    selectedApps.forEach(app => {
                        // Pour L2, v√©rifier si l'app a des capabilities qui correspondent √† ce L1/L2
                        let hasL2 = false;
                        if (app.capabilities && capabilitiesStructure) {
                            hasL2 = app.capabilities.some(capId => {
                                const capData = capabilitiesStructure[capId];
                                return capData && capData.l1_name === l1 && capData.l2_name === l2;
                            });
                        }
                        const cellClass = hasL2 ? 'implemented' : 'not-implemented';
                        const icon = hasL2 ? '‚úì' : '‚úó';
                        html += `<td class="app-column ${cellClass}">${icon}</td>`;
                    });
                    
                    html += `</tr>`;
                });
            });
            
            html += `</tbody></table></div>`;
            return html;
        }

        // Fonction utilitaire pour g√©n√©rer le tableau de comparaison
        function generateComparisonTable(categories, categoryLabel, categoryCount) {
            let html = `
                <div class="comparison-table">
                    <div class="table-header">
                        <h3>Comparaison des ${categoryLabel}</h3>
                        <div class="comparison-stats">
                            <div class="stat-item">${selectedApps.length} Applications</div>
                            <div class="stat-item">${categoryCount} ${categoryLabel}</div>
                        </div>
                    </div>
                    <table class="capability-table">
                        <thead>
                            <tr>
                                <th class="capability-name">Domaine / Processus</th>
            `;

            selectedApps.forEach(app => {
                html += `<th class="app-column">${app.name}</th>`;
            });

            html += `</tr></thead><tbody>`;

            Object.keys(categories).forEach(l1 => {
                // Ligne L1
                html += `<tr class="l1-row">`;
                html += `<td class="capability-name l1-header" colspan="${selectedApps.length + 1}"><strong>üìÅ ${l1}</strong></td>`;
                html += `</tr>`;

                // Lignes L2
                categories[l1].forEach(l2 => {
                    html += `<tr>`;
                    html += `<td class="capability-name l2-name">‚îî‚îÄ ${l2}</td>`;
                    
                    selectedApps.forEach(app => {
                        // V√©rifier si l'application a des L4 qui correspondent √† ce L1/L2
                        let hasCapability = false;
                        if (app.capabilities && capabilitiesStructure) {
                            hasCapability = app.capabilities.some(capId => {
                                const capData = capabilitiesStructure[capId];
                                return capData && capData.l1_name === l1 && capData.l2_name === l2;
                            });
                        } else {
                            // Fallback: simulation al√©atoire
                            hasCapability = Math.random() > 0.3;
                        }
                        
                        const cellClass = hasCapability ? 'implemented' : 'not-implemented';
                        const icon = hasCapability ? '‚úì' : '‚úó';
                        html += `<td class="app-column ${cellClass}">${icon}</td>`;
                    });
                    
                    html += `</tr>`;
                });
            });

        }

        // G√©n√©rer la comparaison L2, L3 (Niveau 2)
        function generateL2L3Comparison() {
            if (!capabilitiesStructure) {
                return `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ùå</div>
                        <h3>Aucune structure trouv√©e</h3>
                        <p>Le fichier capabilities.json n'est pas charg√©</p>
                    </div>
                `;
            }

            // Construire la structure L2 -> L3 bas√©e sur les vraies donn√©es
            const l2Structure = {};
            
            Object.keys(capabilitiesStructure).forEach(capId => {
                const capData = capabilitiesStructure[capId];
                if (capData && capData.l2_name && capData.l3_name) {
                    // Filtrer par L1 si un filtre est actif
                    if (currentL1Filter && capData.l1_name !== currentL1Filter) {
                        return;
                    }
                    
                    if (!l2Structure[capData.l2_name]) {
                        l2Structure[capData.l2_name] = new Set();
                    }
                    l2Structure[capData.l2_name].add(capData.l3_name);
                }
            });

            // Convertir les Sets en arrays et trier
            Object.keys(l2Structure).forEach(l2 => {
                l2Structure[l2] = Array.from(l2Structure[l2]).sort();
            });

            const l2Names = Object.keys(l2Structure).sort();

            if (l2Names.length === 0) {
                return `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìä</div>
                        <h3>Aucun L2/L3 trouv√©</h3>
                        <p>Les applications s√©lectionn√©es n'ont pas de capabilities L2/L3 identifiables${currentL1Filter ? ' pour ' + currentL1Filter : ''}</p>
                    </div>
                `;
            }

            let html = `
                <div class="comparison-table">
                    <div class="table-header">
                        <h3>Comparaison des Processus (L2) et Activit√©s (L3)${currentL1Filter ? ' (' + currentL1Filter + ')' : ''}</h3>
                        <div class="comparison-stats">
                            <div class="stat-item">${selectedApps.length} Applications</div>
                            <div class="stat-item">${l2Names.length} Processus L2</div>
                            <div class="stat-item">${Object.values(l2Structure).reduce((acc, l3s) => acc + l3s.length, 0)} Activit√©s L3</div>
                        </div>
                    </div>
                    <table class="capability-table">
                        <thead>
                            <tr>
                                <th class="capability-name">Processus / Activit√©</th>
            `;

            selectedApps.forEach(app => {
                html += `<th class="app-column">${app.name}</th>`;
            });

            html += `</tr></thead><tbody>`;

            l2Names.forEach(l2 => {
                // Ligne L2 (processus)
                html += `<tr class="l2-row">`;
                html += `<td class="capability-name l2-header"><strong>üìÇ ${l2}</strong></td>`;
                
                selectedApps.forEach(app => {
                    // Pour L2, v√©rifier si l'app a au moins une capability de ce processus
                    let hasL2 = false;
                    if (app.capabilities && capabilitiesStructure) {
                        hasL2 = app.capabilities.some(capId => {
                            const capData = capabilitiesStructure[capId];
                            if (!capData || !capData.l2_name) return false;
                            if (currentL1Filter && capData.l1_name !== currentL1Filter) return false;
                            return capData.l2_name === l2;
                        });
                    }
                    const cellClass = hasL2 ? 'implemented' : 'not-implemented';
                    const icon = hasL2 ? '‚úì' : '‚úó';
                    html += `<td class="app-column ${cellClass}">${icon}</td>`;
                });
                
                html += `</tr>`;

                // Lignes L3 (activit√©s sous ce processus)
                l2Structure[l2].forEach(l3 => {
                    html += `<tr>`;
                    html += `<td class="capability-name l3-name">‚îî‚îÄ ${l3}</td>`;
                    
                    selectedApps.forEach(app => {
                        // Pour L3, v√©rifier si l'app a des capabilities qui correspondent √† ce L2/L3
                        let hasL3 = false;
                        if (app.capabilities && capabilitiesStructure) {
                            hasL3 = app.capabilities.some(capId => {
                                const capData = capabilitiesStructure[capId];
                                if (!capData || !capData.l2_name || !capData.l3_name) return false;
                                if (currentL1Filter && capData.l1_name !== currentL1Filter) return false;
                                return capData.l2_name === l2 && capData.l3_name === l3;
                            });
                        }
                        const cellClass = hasL3 ? 'implemented' : 'not-implemented';
                        const icon = hasL3 ? '‚úì' : '‚úó';
                        html += `<td class="app-column ${cellClass}">${icon}</td>`;
                    });
                    
                    html += `</tr>`;
                });
            });

            html += `</tbody></table></div>`;
            return html;
        }

        // Fonction helper pour cr√©er la structure L3 √† partir des pr√©fixes (√©vite la redondance)
        function createL3StructureFromPrefixes(allL4Keys, capabilitiesStructure) {
            // Cr√©er des groupes par pr√©fixes des L4
            const l4Groups = {};
            allL4Keys.forEach(l4Id => {
                const prefix = l4Id.split('_')[0]; // Ex: CMAC1_1 -> CMAC1
                if (!l4Groups[prefix]) {
                    l4Groups[prefix] = [];
                }
                l4Groups[prefix].push(l4Id);
            });

            // Cr√©er la structure L3 bas√©e sur les pr√©fixes avec vrais noms L3
            const structure = {};
            Object.keys(l4Groups).forEach(prefix => {
                // Chercher un vrai nom L3 correspondant au pr√©fixe
                let l3Name = `Activit√© ${prefix}`;
                let l1Name = 'Business Capabilities';
                let l2Name = 'Processus M√©tier';
                
                if (capabilitiesStructure) {
                    // Chercher dans capabilities.json un capId qui commence par ce pr√©fixe
                    const matchingCapId = Object.keys(capabilitiesStructure).find(capId => 
                        capId.startsWith(prefix.split(/[0-9]/)[0])
                    );
                    if (matchingCapId && capabilitiesStructure[matchingCapId]) {
                        const capData = capabilitiesStructure[matchingCapId];
                        if (capData.l3_name) l3Name = capData.l3_name;
                        if (capData.l1_name) l1Name = capData.l1_name;
                        if (capData.l2_name) l2Name = capData.l2_name;
                    }
                }
                
                structure[l3Name] = {
                    l1_name: l1Name,
                    l2_name: l2Name,
                    l4s: l4Groups[prefix]
                };
            });
            
            return structure;
        }

        // G√©n√©rer la comparaison L3, L4 (Niveau 3 - actuel)
        function generateL3L4Comparison() {
            if (!bcL4Definitions || Object.keys(bcL4Definitions).length === 0) {
                return `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ùå</div>
                        <h3>Aucune d√©finition trouv√©e</h3>
                        <p>Le fichier bc-l4-definitions.json n'est pas charg√© ou est vide</p>
                    </div>
                `;
            }

            // Construire la structure L3 -> L4 en utilisant TOUTES les d√©finitions L4
            const l3Structure = {};
            const allL4Keys = Object.keys(bcL4Definitions).sort();

            // Si on a la structure des capabilities, on peut organiser par L3
            if (capabilitiesStructure) {
                // D'abord cr√©er la structure bas√©e sur capabilities.json
                Object.keys(capabilitiesStructure).forEach(capId => {
                    const capData = capabilitiesStructure[capId];
                    if (capData && capData.l3_name) {
                        // Filtrer par L1 si un filtre est actif
                        if (currentL1Filter && capData.l1_name !== currentL1Filter) {
                            return;
                        }
                        
                        if (!l3Structure[capData.l3_name]) {
                            l3Structure[capData.l3_name] = {
                                l1_name: capData.l1_name,
                                l2_name: capData.l2_name,
                                l4s: new Set()
                            };
                        }
                    }
                });

                // Ensuite, ajouter TOUTES les L4 √† leurs L3 correspondants (si mapping disponible)
                if (window.bcL4Mapping) {
                    Object.keys(capabilitiesStructure).forEach(capId => {
                        const capData = capabilitiesStructure[capId];
                        if (capData && capData.l3_name && window.bcL4Mapping[capId]) {
                            // Filtrer par L1 si actif
                            if (currentL1Filter && capData.l1_name !== currentL1Filter) {
                                return;
                            }
                            
                            window.bcL4Mapping[capId].forEach(l4Id => {
                                if (bcL4Definitions[l4Id]) {
                                    l3Structure[capData.l3_name].l4s.add(l4Id);
                                }
                            });
                        }
                    });
                }

                // Convertir les Sets en arrays
                Object.keys(l3Structure).forEach(l3 => {
                    l3Structure[l3].l4s = Array.from(l3Structure[l3].l4s).sort();
                });

                // Si on n'a pas de mapping ou pas assez de L4, compl√©ter avec fallback
                if (Object.keys(l3Structure).length === 0 || 
                    Object.values(l3Structure).reduce((acc, l3Data) => acc + l3Data.l4s.length, 0) < allL4Keys.length * 0.5) {
                    
                    // Utiliser la fonction helper pour cr√©er la structure fallback
                    const fallbackStructure = createL3StructureFromPrefixes(allL4Keys, capabilitiesStructure);
                    Object.assign(l3Structure, fallbackStructure);
                }
            } else {
                // Pas de structure capabilities, utiliser la fonction helper
                l3Structure = createL3StructureFromPrefixes(allL4Keys, capabilitiesStructure);
            }

            const l3Names = Object.keys(l3Structure).sort();
            const totalL4s = Object.values(l3Structure).reduce((acc, l3Data) => acc + l3Data.l4s.length, 0);

            let html = `
                <div class="comparison-table">
                    <div class="table-header">
                        <h3>Comparaison des Activit√©s (L3) et Business Capabilities (L4)${currentL1Filter ? ' (' + currentL1Filter + ')' : ''}</h3>
                        <div class="comparison-stats">
                            <div class="stat-item">${selectedApps.length} Applications</div>
                            <div class="stat-item">${l3Names.length} Activit√©s L3</div>
                            <div class="stat-item">${totalL4s} Business Capabilities L4</div>
                        </div>
                    </div>
                    <table class="capability-table">
                        <thead>
                            <tr>
                                <th class="capability-name">Activit√© / Business Capability</th>
            `;

            selectedApps.forEach(app => {
                html += `<th class="app-column">${app.name}</th>`;
            });

            html += `</tr></thead><tbody>`;

            l3Names.forEach(l3 => {
                const l3Data = l3Structure[l3];
                
                // Calculer d'abord tous les r√©sultats L4 pour cette L3
                const l3L4Results = [];
                const l3AppCoverage = selectedApps.map(() => false); // Initialement aucune app ne couvre la L3
                
                l3Data.l4s.forEach(l4Id => {
                    const l4Definition = bcL4Definitions[l4Id];
                    
                    // V√©rifier si au moins une application impl√©mente cette L4
                    let atLeastOneAppHasL4 = false;
                    const appResults = selectedApps.map((app, appIndex) => {
                        // Pour L4, logique simul√©e (vous pouvez remplacer par votre vraie logique)
                        const hasL4 = Math.random() > 0.7;
                        if (hasL4) {
                            atLeastOneAppHasL4 = true;
                            l3AppCoverage[appIndex] = true; // Cette app couvre maintenant la L3
                        }
                        return {
                            hasL4,
                            cellClass: hasL4 ? 'implemented' : 'not-implemented',
                            icon: hasL4 ? '‚úì' : '‚úó'
                        };
                    });
                    
                    // Stocker les r√©sultats seulement si au moins une app l'impl√©mente
                    if (atLeastOneAppHasL4) {
                        l3L4Results.push({
                            l4Definition,
                            appResults
                        });
                    }
                });
                
                // Afficher la ligne L3 seulement si elle a des L4 couvertes
                if (l3L4Results.length > 0) {
                    // Ligne L3 (activit√©) - en-t√™te sans indicateurs
                    html += `<tr class="l3-row">`;
                    html += `<td class="capability-name l3-header" colspan="${selectedApps.length + 1}"><strong>üéØ ${l3}</strong><br><small style="opacity: 0.7;">${l3Data.l2_name}</small></td>`;
                    html += `</tr>`;

                    // Afficher toutes les L4 couvertes pour cette L3
                    l3L4Results.forEach(l4Result => {
                        html += `<tr>`;
                        html += `<td class="capability-name l4-name">‚îî‚îÄ ${l4Result.l4Definition}</td>`;
                        
                        l4Result.appResults.forEach(result => {
                            html += `<td class="app-column ${result.cellClass}">${result.icon}</td>`;
                        });
                        
                        html += `</tr>`;
                    });
                }
            });

            html += `</tbody></table></div>`;
            return html;
        }

        // G√©n√©rer le tableau de comparaison original (L3, L4)
        // G√©n√©rer le r√©sum√©
        function generateSummary(allItems) {
            let html = `
                <div class="summary-section">
                    <h3 style="color: #1976d2; margin-bottom: 20px;">üìà R√©sum√© de la comparaison</h3>
                    <div class="summary-grid">
            `;

            selectedApps.forEach(app => {
                // Pour le niveau 3, calculer diff√©remment car on utilise bc-l4-definitions
                let implementedCount;
                if (currentDetailLevel === 3) {
                    // Pour le niveau 3, utiliser une logique simul√©e
                    // Vous pouvez remplacer ceci par votre vraie logique de matching
                    implementedCount = Math.floor(allItems.length * (0.2 + Math.random() * 0.3));
                } else {
                    // Pour les niveaux 1 et 2, utiliser les capabilities r√©elles
                    implementedCount = app.capabilities ? app.capabilities.length : 0;
                }
                
                const percentage = allItems.length > 0 ? Math.round((implementedCount / allItems.length) * 100) : 0;

                html += `
                    <div class="summary-card">
                        <h4>${app.name}</h4>
                        <p>${implementedCount}/${allItems.length} ${currentDetailLevel === 3 ? 'L4 Business Capabilities' : 'Capabilities'} impl√©ment√©es</p>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${percentage}%"></div>
                        </div>
                        <p style="text-align: center; margin-top: 5px; font-weight: bold;">${percentage}%</p>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            return html;
        }

        // Filtrer les applications
        function filterApps() {
            const searchTerm = document.getElementById('app-search').value.toLowerCase();
            const appItems = document.querySelectorAll('.app-item');

            appItems.forEach(item => {
                const appName = item.querySelector('.app-name').textContent.toLowerCase();
                const isVisible = appName.includes(searchTerm);
                item.style.display = isVisible ? 'flex' : 'none';
            });
        }

    </script>
</body>
</html>
